/*
 * generated by Xtext 2.23.0
 */
package org.sodalite.sdl.ansible.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EReference
import org.sodalite.sdl.ansible.ansibleDsl.AnsibleDslPackage
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.EcoreUtil2
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlayImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EVariableDeclarationImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EDictionaryImpl
import java.util.ArrayList
import org.sodalite.sdl.ansible.ansibleDsl.EDictionaryPair
import org.sodalite.sdl.ansible.ansibleDsl.impl.EDictionaryPairReferenceImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlaybookImpl
import org.sodalite.dsl.rM.impl.EParameterDefinitionImpl
import org.sodalite.dsl.rM.impl.EOperationDefinitionImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EVariableDeclarationVariableReferenceImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ERegisterVariableReferenceImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ERegisterVariableImpl
import org.sodalite.dsl.rM.impl.EInterfaceDefinitionBodyImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EInputOperationVariableReferenceImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EInputInterfaceVariableReferenceImpl
import org.sodalite.dsl.rM.EPropertyDefinition
import org.sodalite.sdl.ansible.ansibleDsl.impl.ENotifiedHandlerImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EHandlerImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EUsedByBodyImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ENotifiedTopicImpl

/** 
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class AnsibleDslScopeProvider extends AbstractAnsibleDslScopeProvider {
	override IScope getScope(EObject context, EReference reference) {
		//scope for variables declared only in this specific play
		if (context instanceof EVariableDeclarationVariableReferenceImpl && reference == AnsibleDslPackage.Literals.EVARIABLE_DECLARATION_VARIABLE_REFERENCE__VARIABLE_DECLARATION_VARIABLE_REFERENCE){
			val rootPlay = EcoreUtil2.getContainerOfType(context, EPlayImpl)
			if (rootPlay !== null){
				val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EVariableDeclarationImpl)
				return Scopes.scopeFor(candidates)
			}
		}
		
		//scope for variables registered only in this specific play
		if (context instanceof ERegisterVariableReferenceImpl && reference == AnsibleDslPackage.Literals.EREGISTER_VARIABLE_REFERENCE__REGISTER_VARIABLE_REFERENCE){
			val rootPlay = EcoreUtil2.getContainerOfType(context, EPlayImpl)
			if (rootPlay !== null){
				val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, ERegisterVariableImpl)
				return Scopes.scopeFor(candidates)
			}
		}
		
		//scope for handlers defined only in this specific play
		if (context instanceof ENotifiedHandlerImpl && reference == AnsibleDslPackage.Literals.ENOTIFIED_HANDLER__NAME){
			val rootPlay = EcoreUtil2.getContainerOfType(context, EPlayImpl)
			if (rootPlay !== null){
				val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EHandlerImpl)
				return Scopes.scopeFor(candidates)
			}
		}
		
		/*if (context instanceof EDictionaryPairReferenceImpl && reference == AnsibleDslPackage.Literals.EDICTIONARY_PAIR_REFERENCE__NAME){
			val declaredVariableReference = EcoreUtil2.getContainerOfType(context, EVariableDeclarationVariableReferenceImpl)
			val tail = declaredVariableReference.tail
			val index = tail.indexOf(context)
			var candidatesOfDictionary = new ArrayList<EDictionaryPair>
			if (index > 0){
				val previousDictionaryPair = tail.get(index - 1).name
				if (previousDictionaryPair.value instanceof EDictionaryImpl){
					for (dictionaryPair : (previousDictionaryPair.value as EDictionaryImpl).dictionary_pairs){
						candidatesOfDictionary.add(dictionaryPair)
					}
				}
			}
			else {
				if (declaredVariableReference.variable_declaration_variable_reference instanceof EVariableDeclarationImpl){
					if ((declaredVariableReference.variable_declaration_variable_reference as EVariableDeclarationImpl).value_passed instanceof EDictionaryImpl){
						for (dictionaryPair : (((declaredVariableReference.variable_declaration_variable_reference as EVariableDeclarationImpl).value_passed) as EDictionaryImpl).dictionary_pairs){
							candidatesOfDictionary.add(dictionaryPair)
						}
					}
				}
			}
			return Scopes.scopeFor(candidatesOfDictionary)
		}*/
		
		if (context instanceof EUsedByBodyImpl && reference == AnsibleDslPackage.Literals.EUSED_BY_BODY__OPERATION){
			val nodeType = (context as EUsedByBodyImpl).node_type
			if (nodeType !== null){
				val candidates = EcoreUtil2.getAllContentsOfType(nodeType, EOperationDefinitionImpl)
				return Scopes.scopeFor(candidates)
			}
		}
		
		if (context instanceof EInputOperationVariableReferenceImpl && reference == AnsibleDslPackage.Literals.EINPUT_OPERATION_VARIABLE_REFERENCE__NAME){
			val rootPlaybook = EcoreUtil2.getContainerOfType(context, EPlaybookImpl)
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					//the variables to scope for are the inputs of the specific operation in the RM
					val candidates = EcoreUtil2.getAllContentsOfType(operation, EParameterDefinitionImpl)
					return Scopes.scopeFor(candidates)
				}	
			}
		}
		
		if (context instanceof EInputInterfaceVariableReferenceImpl && reference == AnsibleDslPackage.Literals.EINPUT_INTERFACE_VARIABLE_REFERENCE__NAME){
			val rootPlaybook = EcoreUtil2.getContainerOfType(context, EPlaybookImpl)
			val candidates = new ArrayList<EPropertyDefinition>
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					//the variables to scope for are the inputs defined in the specific interface in the RM
					val interfaceDefinitionBody = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionBodyImpl)
					val inputsProperties = interfaceDefinitionBody.inputs
					for (input : inputsProperties.properties){
						candidates.add(input)
					}
					return Scopes.scopeFor(candidates)
				}				
			}
		}
		
		//the topics to scope for are only the once defined in the current play
		if (context instanceof EHandlerImpl && reference == AnsibleDslPackage.Literals.EHANDLER__LISTEN_TO){
			val rootPlay = EcoreUtil2.getContainerOfType(context, EPlayImpl)
			if (rootPlay !== null){
				val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, ENotifiedTopicImpl)
				return Scopes.scopeFor(candidates)
			}
		}
		
		
		
		return super.getScope(context, reference);
	}
}
