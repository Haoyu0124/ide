/*
 * generated by Xtext 2.23.0
 */
package org.sodalite.sdl.ansible.ui.contentassist

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlayImpl
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.Assignment
import org.sodalite.sdl.ansible.ansibleDsl.impl.EVariableDeclarationImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ERegisterVariableImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EHandlerImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlaybookImpl
import org.sodalite.dsl.rM.impl.EParameterDefinitionImpl
import org.sodalite.dsl.rM.impl.EInterfaceDefinitionBodyImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EIndexOrLoopVariableImpl
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.sodalite.sdl.ansible.ansibleDsl.impl.EUsedByBodyImpl
import org.sodalite.dsl.rM.impl.EOperationDefinitionImpl
import org.sodalite.dsl.rM.impl.EInterfaceDefinitionImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ENotifiedTopicImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EParameterImpl
import java.util.ArrayList
import org.sodalite.sdl.ansible.ansibleDsl.EParameter
import org.sodalite.sdl.ansible.ansibleDsl.impl.EModuleCallImpl
import org.eclipse.jface.viewers.StyledString

/** 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
class AnsibleDslProposalProvider extends AbstractAnsibleDslProposalProvider {
	
	final String PRIVILEGE_ESCALATION_DESCRIPTION = 
	"This is used for setting up the privilege escalation.\n\n" + 
	"The attributes that can be set are:\n\n"+
	"	- become   -> bool\n"+
	"	- become_exe   -> string\n"+
	"	- become_flags   -> string\n"+
	"	- become_method   -> string\n"+
	"	- become_user   -> string"
	
	final String VALIDATION_MODE_DESCRIPTION =
	"This is used for setting up the two modes of execution that validate tasks.\n\n"+
	"The two modes, and the correspondent attributes that can be set, are:\n\n"+
	"	- check_mode   -> bool\n"+
	"	- diff   -> bool"
	
	final String CONNECTION_INFO_DESCRIPTION = 
	"This is used for defining the settings of the connection.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- connection   -> string\n"+
	"	- port   -> int\n"+
	"	- remote_user   -> string"
	
	final String PLAY_EXE_SETTINGS_DESCRIPTION =
	"This is used for controlling the execution of the play.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- strategy   -> string\n"+
	"	- serial   -> list\n"+
	"	- order   -> string\n"+
	"	- throttle   -> int\n"+
	"	- run_once   -> bool"
	
	final String PLAY_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a play.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- max_fail_percentage   -> percentage\n"+
	"	- any_errors_fatal   -> bool\n"+
	"	- ignore_errors   -> bool\n"+
	"	- ignore_unreachable   -> bool"
	
	final String FACTS_SETTINGS_DESCRIPTION =
	"This is used for setting up how the gathering of facts is handled.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- gather_facts   -> bool\n"+
	"	- gather_subset   -> list\n"+
	"	- gather_timeout   -> int\n"+
	"	- fact_path   -> string"
	
	final String EXECUTION_EXE_SETTINGS_DESCRIPTION =
	"This is used for controlling the execution of the task/block/handler/role.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- throttle   -> int\n"+
	"	- run_once   -> bool"
	
	final String DELEGATION_DESCRIPTION =
	"This is used for setting up the delegation settings.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- delegate_to   -> string\n"+
	"	- delegate_facts   -> bool"
	
	final String BLOCK_AND_ROLE_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a block/role inclusion.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- any_errors_fatal   -> bool\n"+
	"	- ignore_errors   -> bool\n"+
	"	- ignore_unreachable   -> bool"
	
	final String TASK_HANDLER_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- changed_when   -> condition\n"+
	"	- failed_when   -> condition\n"+
	"	- any_errors_fatal   -> bool\n"+
	"	- ignore_errors   -> bool\n"+
	"	- ignore_unreachable   -> bool"
	
	final String ASYNCHRONOUS_SETTINGS_DESCRIPTION =
	"This is used for setting up the asynchronous behavior of a task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- async   -> int\n"+
	"	- poll   -> int"
	
	final String MODULE_CALL_DESCRIPTION =
	"This is used for defining which is the module to be used in this task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- module: it's the identifier of the module to be used.\n"+
	"	- direct_parameter: it's a value passed to the module without an explicit\n"+
	"	  	  name of the parameter, like it's done for example with shell module.\n"+
	"	  	  This attribute isn't mandatory.\n"+
	"	- parameters: it's just the keyword for defining the list of couples\n"+
	"	  	  'identifier of the parameter'-'value passed to it'"
	
	final String LOOP_DESCRIPTION =
	"This is used for defining a loop over the current task/handler.\n\n"+
	"There are 3 types of loops and 3 correspondent attributes:\n\n"+
	"	- loop_over: when the loop is done over a list of values.\n"+
	"	  	  This attribute allows to specify which is the list.\n"+
	"	  	  In this case the additional entity 'loop_control' can be used\n"+
	"	  	  for specifying additional properties of the loop.\n"+
	"	- with: the 'with_<lookup>' keyword for doing loops in Ansible.\n"+
	"	- until: when the operations are repeated until a condition is met.\n"+
	"	  	  This attribute allows to specify the end condition to meet.\n"+
	"	  	  Two additional attributes that can be set in this case are:\n"+
	"	   	  	 - retries   -> int\n"+
	"	   	   	 - delay   -> int\n"
	
	final String LOOP_CONTROL_DESCRIPTION =
	"This is used for setting up how the loop over a list is done.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- label   -> string\n"+
	"	- pause   -> float\n"+
	"	- index_var   -> identifier of the var\n"+
	"	- loop_var   -> identifier of the var\n"+
	"	- extended   -> bool"
	
	final String USED_BY_DESCRIPTION =
	"This is the bridge between this Ansible model and the TOSCA RM.\n\n"+
	"Here it can be defined which is the TOSCA operation that will use this\n"+
	"playbook for its implementation.\n\n"+
	"The attributes that can be set are (they are both strings):\n\n"+
	"	- node_type: the node type containing the operation.\n"+
	"	- operation: the operation that uses this playbook for its implementation\n."+
	"			The operation must be contained in an interface of the selected\n"+
	"			node type."
	
	final String PLAYBOOK_INCLUSION_DESCRIPTION =
	"This is used for importing a playbook yaml file.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- import_playbook   -> the name of the yaml file\n"+
	"	- when   -> condition"
	
	final String WITH_LOOKUP_DESCRIPTION =
	"This is the classic 'with_<lookup>' keyword in Ansible.\n"+
	"The user is supposed to write 'with' followed by a space and the <lookup>.\n"+
	"Writing for example 'with items:' will be translated into 'with_items:'."
	
	override void complete_EPrivilegeEscalation(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("privilege_escalation:", new StyledString("privilege_escalation:"), context, PRIVILEGE_ESCALATION_DESCRIPTION, acceptor)
	}
	
	override void complete_EValidationMode(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("validation_mode:", new StyledString("validation_mode:"), context, VALIDATION_MODE_DESCRIPTION, acceptor)
	}
	
	override void complete_EConnection(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("connection_info:", new StyledString("connection_info:"), context, CONNECTION_INFO_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlayExeSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("play_exe_settings:", new StyledString("play_exe_settings:"), context, PLAY_EXE_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlayErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("error_handling:", new StyledString("error_handling:"), context, PLAY_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_EFactsSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("facts_settings:", new StyledString("facts_settings:"), context, FACTS_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EExecutionExeSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("exe_settings:", new StyledString("exe_settings:"), context, EXECUTION_EXE_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EDelegation(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("delegation:", new StyledString("delegation:"), context, DELEGATION_DESCRIPTION, acceptor)
	}
	
	override void complete_EBlockAndRoleErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("error_handling:", new StyledString("error_handling:"), context, BLOCK_AND_ROLE_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_ETaskHandlerErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("error_handling:", new StyledString("error_handling:"), context, TASK_HANDLER_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_EAsynchronousSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("asynchronous_settings:", new StyledString("asynchronous_settings:"), context, ASYNCHRONOUS_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EModuleCall(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("module:", new StyledString("module:"), context, MODULE_CALL_DESCRIPTION, acceptor)
	}
	
	override void complete_ELoop(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("loop:", new StyledString("loop:"), context, LOOP_DESCRIPTION, acceptor)
	}
	
	override void complete_ELoopControl(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("loop_control:", new StyledString("loop_control:"), context, LOOP_CONTROL_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlaybookInclusion(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("playbook_inclusion:", new StyledString("playbook_inclusion:"), context, PLAYBOOK_INCLUSION_DESCRIPTION, acceptor)
	}
	
	override void complete_EUsedByBody(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("used_by:", new StyledString("used_by:"), context, USED_BY_DESCRIPTION, acceptor)
	}
	
	override void completeEPlaybookInclusion_Playbook_file_name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createEditableCompletionProposal("\"playbook_imported.yaml\"", "\"playbook_imported.yaml\"", context, "The yaml file of the playbook to import.", acceptor)
	}
	
	override void complete_EWithLookup(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("with", new StyledString("with"), context, WITH_LOOKUP_DESCRIPTION, acceptor)
	}
	
	override void complete_BOOLEAN(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("False", context));
		acceptor.accept(createCompletionProposal("True", context));
	}

	override void complete_BOOLEAN_ONLY_ANSIBLE(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("no", context));
		acceptor.accept(createCompletionProposal("yes", context));
		acceptor.accept(createCompletionProposal("false", context));
		acceptor.accept(createCompletionProposal("true", context));
	}
	
	override void complete_NULL(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("Null", context));
	}
	
	override void complete_NUMBER(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createEditableCompletionProposal("0", "0 - NUMBER", context, "A number", acceptor)
	}
	
	override void completeEForStatement_Recursive(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("recursive", context))
	}
	
	//suggests variables declared only in this specific play
	override void completeEVariableDeclarationVariableReference_Variable_declaration_variable_reference(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EVariableDeclarationImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal(candidate.name, context))
			}
		}		
	}

	//suggests variables registered only in this specific play
	override void completeERegisterVariableReference_Register_variable_reference(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, ERegisterVariableImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal(candidate.name, context))
			}
		}
	}
	
	//suggest handlers defined only in this specific play
	override void completeENotifiedHandler_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EHandlerImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal("\"".concat(candidate.name).concat("\""), context))
			}
		}
	}

	//suggest variables given in input by the tosca operation
	override void completeEInputOperationVariableReference_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlaybook = EcoreUtil2.getContainerOfType(model, EPlaybookImpl)
		if (rootPlaybook !== null){
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					val candidatesInputVariableOperation = EcoreUtil2.getAllContentsOfType(operation, EParameterDefinitionImpl)
					for (candidate: candidatesInputVariableOperation){
						createNonEditableCompletionProposal("\"".concat(candidate.name).concat("\""), new StyledString("\"".concat(candidate.name).concat("\""), StyledString.COUNTER_STYLER).append(" - RM input"), context, "An input variable from the '" + operation.name + "' operation.", acceptor)
					}
				}
			}	
		}
	}
	
	//suggest variables given in input by the tosca interface
	override void completeEInputInterfaceVariableReference_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlaybook = EcoreUtil2.getContainerOfType(model, EPlaybookImpl)
		if (rootPlaybook !== null){
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					val interfaceDefinitionBody = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionBodyImpl)
					val interfaceDefinition = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionImpl)
					val inputsProperties = interfaceDefinitionBody.inputs
					for (input : inputsProperties.properties){
						createNonEditableCompletionProposal("\"".concat(input.name).concat("\""), new StyledString("\"".concat(input.name).concat("\""), StyledString.COUNTER_STYLER).append(" - RM input"), context, "An input variable from the '" + interfaceDefinition.name + "' interface.", acceptor)
					}
				}				
			}			
		}
	}
	
	//suggest all the possible variables that can be referenced
	override void complete_EVariableReference(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			//suggest variables declared only in this specific play
			val candidatesDeclaredVariables = EcoreUtil2.getAllContentsOfType(rootPlay, EVariableDeclarationImpl)
			for (candidate: candidatesDeclaredVariables){
				createNonEditableCompletionProposal("declared_variable: ".concat(candidate.name), new StyledString("declared_variable: ").append(candidate.name, StyledString.COUNTER_STYLER), context, "A variable declared in this play.", acceptor)
			}
			//suggest variables registered only in this specific play
			val candidatesRegisteredVariables = EcoreUtil2.getAllContentsOfType(rootPlay, ERegisterVariableImpl)
			for (candidate: candidatesRegisteredVariables){
				createNonEditableCompletionProposal("registered_variable: ".concat(candidate.name), new StyledString("registered_variable: ").append(candidate.name, StyledString.COUNTER_STYLER), context, "A variable registered in this play.", acceptor)
			}
			//suggest index or loop variables defined only in this specific play
			val candidatesIndexOrLoopVariables = EcoreUtil2.getAllContentsOfType(rootPlay, EIndexOrLoopVariableImpl)
			for (candidate: candidatesIndexOrLoopVariables){
				createNonEditableCompletionProposal("index_or_loop_var: ".concat(candidate.name), new StyledString("index_or_loop_var: ").append(candidate.name, StyledString.COUNTER_STYLER), context, "A variable defined with the 'index_var' or 'loop_var' keyword.", acceptor)
			}
			
			//suggest variables set in a "set_fact" module in this specific playbook
			val rootPlaybook = EcoreUtil2.getContainerOfType(model, EPlaybookImpl)
			val candidatesSetFactsVariables = EcoreUtil2.getAllContentsOfType(rootPlaybook, EParameterImpl)
			//the parameters candidates should be only the ones set in a "set_fact" module
			var legitCandidatesSetFactsVariables = new ArrayList<EParameter>
			for (parameter: candidatesSetFactsVariables){
				val moduleCall = EcoreUtil2.getContainerOfType(parameter, EModuleCallImpl)
				if (moduleCall !== null){
					if (moduleCall.name == "set_fact") legitCandidatesSetFactsVariables.add(parameter)
				}
			}
			for (candidate: legitCandidatesSetFactsVariables){
				createNonEditableCompletionProposal("fact_set: ".concat(candidate.name), new StyledString("fact_set: ").append(candidate.name, StyledString.COUNTER_STYLER), context, "A variable set with the 'set_fact' module in this playbook.", acceptor)
			}
			
			//the following piece of code is for variables given as input by the RM
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					//suggest variables given in input by the tosca operation
					val candidatesInputVariableOperation = EcoreUtil2.getAllContentsOfType(operation, EParameterDefinitionImpl)
					for (candidate: candidatesInputVariableOperation){
						createNonEditableCompletionProposal("operation_input: ".concat("\"").concat(candidate.name).concat("\""), new StyledString("operation_input: ").append("\"".concat(candidate.name).concat("\""), StyledString.COUNTER_STYLER).append(" - RM input"), context, "An input variable from the '" + operation.name + "' operation.", acceptor)
					}
					//suggest variables given in input by the tosca interface
					val interfaceDefinitionBody = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionBodyImpl)
					val interfaceDefinition = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionImpl)
					val inputsProperties = interfaceDefinitionBody.inputs
					for (input : inputsProperties.properties){
						createNonEditableCompletionProposal("interface_input: ".concat("\"").concat(input.name).concat("\""), new StyledString("interface_input: ").append("\"".concat(input.name).concat("\""), StyledString.COUNTER_STYLER).append(" - RM input"), context, "An input variable from the '" + interfaceDefinition.name + "' interface.", acceptor)
					}
				}
			}

		}
	}
	
	//the operations suggested must belong to an interface of the selected node type
	override void completeEUsedByBody_Operation(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val playbook = EcoreUtil2.getContainerOfType(model, EPlaybookImpl)
		if (playbook !== null){
			val usedByBody = playbook.used_by
			if (usedByBody !== null){
				val nodeType = usedByBody.node_type
				if (nodeType !== null){
					val candidatesOperation = EcoreUtil2.getAllContentsOfType(nodeType, EOperationDefinitionImpl)
					for (candidate: candidatesOperation){
						val interfaceDefinition = EcoreUtil2.getContainerOfType(candidate, EInterfaceDefinitionImpl)
						createNonEditableCompletionProposal("\"".concat(candidate.name).concat("\""), new StyledString(candidate.name.concat(" - Interface: ")).append(interfaceDefinition.name, StyledString.COUNTER_STYLER), context, "One of the operations belonging to the selected node type.", acceptor)
					}
				}
			}
		}
	}
	
	//the suggested topics to which listen to are only the once defined in the current play
	override void completeEHandler_Listen_to(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidatesTopics = EcoreUtil2.getAllContentsOfType(rootPlay, ENotifiedTopicImpl)
			for (candidate: candidatesTopics){
				acceptor.accept(createCompletionProposal("\"".concat(candidate.name).concat("\""), context))
			}
		}
	}
	
	override void completeEWithLookup_Lookup(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var lookups = new ArrayList<String>
		lookups.add("list")
		lookups.add("items")
		lookups.add("indexed_items")
		lookups.add("flattened")
		lookups.add("together")
		lookups.add("dict")
		lookups.add("sequence")
		lookups.add("subelements")
		lookups.add("nested")
		lookups.add("cartesian")
		lookups.add("random_choice")
		
		for (lookup : lookups) acceptor.accept(createCompletionProposal(lookup, context))
	}
	
	//suggest the "special variables": the ones described here: https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html
	//even if not listed in the web site linked above, "item" is suggested here as well
	override void completeESpecialVariable_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var specialVariables = new ArrayList<String>
		specialVariables.add("item")
		//"magic variables" (see web site linked above)
		specialVariables.add("ansible_check_mode")
		specialVariables.add("ansible_config_file")
		specialVariables.add("ansible_dependent_role_names")
		specialVariables.add("ansible_diff_mode")
		specialVariables.add("ansible_forks")
		specialVariables.add("ansible_inventory_sources")
		specialVariables.add("ansible_limit")
		specialVariables.add("ansible_loop")
		specialVariables.add("ansible_loop_var")
		specialVariables.add("ansible_index_var")
		specialVariables.add("ansible_parent_role_names")
		specialVariables.add("ansible_parent_role_paths")
		specialVariables.add("ansible_play_batch")
		specialVariables.add("ansible_play_hosts")
		specialVariables.add("ansible_play_hosts_all")
		specialVariables.add("ansible_play_roles_names")
		specialVariables.add("ansible_playbook_python")
		specialVariables.add("ansible_role_names")
		specialVariables.add("ansible_role_name")
		specialVariables.add("ansible_collection_name")
		specialVariables.add("ansible_run_tags")
		specialVariables.add("ansible_search_path")
		specialVariables.add("ansible_skip_tags")
		specialVariables.add("ansible_verbosity")
		specialVariables.add("ansible_version")
		specialVariables.add("group_names")
		specialVariables.add("groups")
		specialVariables.add("hostvars")
		specialVariables.add("inventory_hostname")
		specialVariables.add("inventory_hostname_short")
		specialVariables.add("inventory_dir")
		specialVariables.add("inventory_file")
		specialVariables.add("omit")
		specialVariables.add("play_hosts")
		specialVariables.add("ansible_play_name")
		specialVariables.add("playbook_dir")
		specialVariables.add("role_name")
		specialVariables.add("role_names")
		specialVariables.add("role_path")
		//"facts" (see web site linked above)
		specialVariables.add("ansible_facts")
		specialVariables.add("ansible_local")
		//"connection variables" (see website linked above)
		specialVariables.add("ansible_become_user")
		specialVariables.add("ansible_connection")
		specialVariables.add("ansible_host")
		specialVariables.add("ansible_python_interpreter")
		specialVariables.add("ansible_user")
		
		for (specialVariable : specialVariables) acceptor.accept(createCompletionProposal(specialVariable, context))
	}
	
	def void createNonEditableCompletionProposal(String proposalText, StyledString displayText,
	ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
			configurable.setAutoInsertable(false);
		}
		acceptor.accept(proposal)
	}
	
	def void createEditableCompletionProposal(String proposalText, String displayText,
		ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setSelectionStart(configurable.getReplacementOffset());
			configurable.setSelectionLength(proposalText.length());
			configurable.setAutoInsertable(false);
			configurable.setSimpleLinkedMode(context.getViewer(), '\t', ' ');
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
		}
		acceptor.accept(proposal)
	}
}
