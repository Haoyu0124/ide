/*
 * generated by Xtext 2.23.0
 */
package org.sodalite.sdl.ansible.ui.contentassist

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlayImpl
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.Assignment
import org.sodalite.sdl.ansible.ansibleDsl.impl.EVariableDeclarationImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ERegisterVariableImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EHandlerImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EPlaybookImpl
import org.sodalite.dsl.rM.impl.EParameterDefinitionImpl
import org.sodalite.dsl.rM.impl.EInterfaceDefinitionBodyImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.EIndexOrLoopVariableImpl
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.CrossReference
import org.sodalite.sdl.ansible.ansibleDsl.impl.EUsedByBodyImpl
import org.sodalite.dsl.rM.impl.EOperationDefinitionImpl
import org.sodalite.dsl.rM.impl.EInterfaceDefinitionImpl
import org.sodalite.sdl.ansible.ansibleDsl.impl.ENotifiedTopicImpl

/** 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
class AnsibleDslProposalProvider extends AbstractAnsibleDslProposalProvider {
	
	final String PRIVILEGE_ESCALATION_DESCRIPTION = 
	"This is used for setting up the privilege escalation.\n\n" + 
	"The attributes that can be set are:\n\n"+
	"	- become\n"+
	"	- become_exe\n"+
	"	- become_flags\n"+
	"	- become_method\n"+
	"	- become_user"
	
	final String VALIDATION_MODE_DESCRIPTION =
	"This is used for setting up the two modes of execution that validate tasks.\n\n"+
	"The two modes, and the correspondent attributes that can be set, are:\n\n"+
	"	- check_mode\n"+
	"	- diff"
	
	final String CONNECTION_INFO_DESCRIPTION = 
	"This is used for defining the settings of the connection.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- connection\n"+
	"	- port\n"+
	"	- remote_user"
	
	final String PLAY_EXE_SETTINGS_DESCRIPTION =
	"This is used for controlling the execution of the play.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- strategy\n"+
	"	- serial\n"+
	"	- order\n"+
	"	- throttle\n"+
	"	- run_once"
	
	final String PLAY_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a play.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- max_fail_percentage\n"+
	"	- any_errors_fatal\n"+
	"	- ignore_errors\n"+
	"	- ignore_unreachable"
	
	final String FACTS_SETTINGS_DESCRIPTION =
	"This is used for setting up how the gathering of facts is handled.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- gather_facts\n"+
	"	- gather_subset\n"+
	"	- gather_timeout\n"+
	"	- fact_path"
	
	final String EXECUTION_EXE_SETTINGS_DESCRIPTION =
	"This is used for controlling the execution of the task/block/handler/role.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- throttle\n"+
	"	- run_once"
	
	final String DELEGATION_DESCRIPTION =
	"This is used for setting up the delegation settings.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- delegate_to\n"+
	"	- delegate_facts"
	
	final String BLOCK_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a block.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- any_errors_fatal\n"+
	"	- ignore_errors\n"+
	"	- ignore_unreachable"
	
	final String TASK_HANDLER_ERROR_HANDLING_DESCRIPTION =
	"This is used for setting up how to handle the errors in a task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- changed_when\n"+
	"	- failed_when\n"+
	"	- any_errors_fatal\n"+
	"	- ignore_errors\n"+
	"	- ignore_unreachable"
	
	final String ASYNCHRONOUS_SETTINGS_DESCRIPTION =
	"This is used for setting up the asynchronous behavior of a task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- async\n"+
	"	- poll"
	
	final String MODULE_CALL_DESCRIPTION =
	"This is used for defining which is the module to be used in this task/handler.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- module_name: it's the identifier of the module to be used.\n"+
	"	- direct_parameter: it's a value passed to the module without an explicit\n"+
	"	   name of the parameter, like it's done for example with the shell module.\n"+
	"	   This attribute isn't mandatory.\n"+
	"	- parameters: it's just the keyword for defining the list of couples\n"+
	"	   'identifier of the parameter'-'value passed to it'"
	
	final String LOOP_DESCRIPTION =
	"This is used for defining a loop over the current task/handler.\n\n"+
	"There are two types of loops and two correspondent attributes:\n\n"+
	"	- loop_over: when the loop is done over a list of values.\n"+
	"	   This attribute allows to specify which is the list.\n"+
	"	   In this case the additional entity 'loop_control' can be used\n"+
	"	   for specifying additional properties of the loop.\n"+
	"	- until: when the operations are repeated until a condition is met.\n"+
	"	   This attribute allows to specify the end condition to meet.\n"+
	"	   Two additional attributes that can be set in this case are:\n"+
	"	   	- retries\n"+
	"	   	- delay\n"
	
	final String LOOP_CONTROL_DESCRIPTION =
	"This is used for setting up how the loop over a list is done.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- label\n"+
	"	- pause\n"+
	"	- index_var\n"+
	"	- loop_var\n"+
	"	- extended"
	
	final String PLAYBOOK_INCLUSION_DESCRIPTION =
	"This is used for importing a playbook yaml file.\n\n"+
	"The attributes that can be set are:\n\n"+
	"	- import_playbook\n"+
	"	- when"
	
	override void complete_EPrivilegeEscalation(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("privilege_escalation:", "privilege_escalation:", context, PRIVILEGE_ESCALATION_DESCRIPTION, acceptor)
	}
	
	override void complete_EValidationMode(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("validation_mode:", "validation_mode:", context, VALIDATION_MODE_DESCRIPTION, acceptor)
	}
	
	override void complete_EConnection(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("connection_info:", "connection_info:", context, CONNECTION_INFO_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlayExeSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("play_exe_settings:", "play_exe_settings:", context, PLAY_EXE_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlayErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("play_error_handling:", "play_error_handling:", context, PLAY_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_EFactsSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("facts_settings:", "facts_settings:", context, FACTS_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EExecutionExeSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("exe_settings:", "exe_settings:", context, EXECUTION_EXE_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EDelegation(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("delegation:", "delegation:", context, DELEGATION_DESCRIPTION, acceptor)
	}
	
	override void complete_EBlockErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("block_error_handling:", "block_error_handling:", context, BLOCK_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_ETaskHandlerErrorHandling(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("error_handling:", "error_handling:", context, TASK_HANDLER_ERROR_HANDLING_DESCRIPTION, acceptor)
	}
	
	override void complete_EAsynchronousSettings(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("asynchronous_settings:", "asynchronous_settings:", context, ASYNCHRONOUS_SETTINGS_DESCRIPTION, acceptor)
	}
	
	override void complete_EModuleCall(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("module_call:", "module_call:", context, MODULE_CALL_DESCRIPTION, acceptor)
	}
	
	override void complete_ELoop(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("loop:", "loop:", context, LOOP_DESCRIPTION, acceptor)
	}
	
	override void complete_ELoopControl(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("loop_control:", "loop_control:", context, LOOP_CONTROL_DESCRIPTION, acceptor)
	}
	
	override void complete_EPlaybookInclusion(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createNonEditableCompletionProposal("playbook_inclusion:", "playbook_inclusion:", context, PLAYBOOK_INCLUSION_DESCRIPTION, acceptor)
	}
	
	override void complete_BOOLEAN(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("False", context));
		acceptor.accept(createCompletionProposal("True", context));
	}
	
	override void complete_NULL(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("Null", context));
	}
	
	//suggests variables declared only in this specific play
	override void completeEVariableDeclarationVariableReference_Variable_declaration_variable_reference(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EVariableDeclarationImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal(candidate.name, context))
			}
		}		
	}

	//suggests variables registered only in this specific play
	override void completeERegisterVariableReference_Register_variable_reference(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, ERegisterVariableImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal(candidate.name, context))
			}
		}
	}
	
	//suggest handlers defined only in this specific play
	override void completeENotifiedHandler_Name(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidates = EcoreUtil2.getAllContentsOfType(rootPlay, EHandlerImpl)
			for (candidate: candidates){
				acceptor.accept(createCompletionProposal("\"".concat(candidate.name).concat("\""), context))
			}
		}
	}
	
	//suggest all the possible variables that can be referenced
	override void complete_EVariableReference(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor){
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			//suggest variables declared only in this specific play
			val candidatesDeclaredVariables = EcoreUtil2.getAllContentsOfType(rootPlay, EVariableDeclarationImpl)
			for (candidate: candidatesDeclaredVariables){
				acceptor.accept(createCompletionProposal("declared_variable: ".concat(candidate.name), context))
			}
			//suggest variables registered only in this specific play
			val candidatesRegisteredVariables = EcoreUtil2.getAllContentsOfType(rootPlay, ERegisterVariableImpl)
			for (candidate: candidatesRegisteredVariables){
				acceptor.accept(createCompletionProposal("registered_variable: ".concat(candidate.name), context))
			}
			//suggest index or loop variables defined only in this specific play
			val candidatesIndexOrLoopVariables = EcoreUtil2.getAllContentsOfType(rootPlay, EIndexOrLoopVariableImpl)
			for (candidate: candidatesIndexOrLoopVariables){
				acceptor.accept(createCompletionProposal("index_or_loop_var: ".concat(candidate.name), context))
			}
			
			val rootPlaybook = EcoreUtil2.getContainerOfType(model, EPlaybookImpl)
			val usedByBody = rootPlaybook.used_by
			if (usedByBody !== null){
				val operation = usedByBody.operation
				if (operation !== null){
					//suggest variables given in input by the tosca operation
					val candidatesInputVariableOperation = EcoreUtil2.getAllContentsOfType(operation, EParameterDefinitionImpl)
					for (candidate: candidatesInputVariableOperation){
						acceptor.accept(createCompletionProposal("operation_input: ".concat("\"").concat(candidate.name).concat("\""), context))
					}
					//suggest variables given in input by the tosca interface
					val interfaceDefinitionBody = EcoreUtil2.getContainerOfType(operation, EInterfaceDefinitionBodyImpl)
					val inputsProperties = interfaceDefinitionBody.inputs
					for (input : inputsProperties.properties){
						acceptor.accept(createCompletionProposal("interface_input: ".concat("\"").concat(input.name).concat("\""), context))
					}
				}				
			}

		}
	}
	
	override void completeEUsedByBody_Operation(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val useByBody = EcoreUtil2.getContainerOfType(model, EUsedByBodyImpl)
		val nodeType = useByBody.node_type
			if (nodeType !== null){
				val candidatesOperation = EcoreUtil2.getAllContentsOfType(nodeType, EOperationDefinitionImpl)
				for (candidate: candidatesOperation){
					val interfaceDefinition = EcoreUtil2.getContainerOfType(candidate, EInterfaceDefinitionImpl)
					createNonEditableCompletionProposal("\"".concat(candidate.name).concat("\""), candidate.name.concat(" - Interface: ").concat(interfaceDefinition.name), context, "One of the operations belonging to the selected node type.", acceptor)
				}
			}		
	}
	
	//the suggested topics to which listen to are only the once defined in the current play
	override void completeEHandler_Listen_to(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val rootPlay = EcoreUtil2.getContainerOfType(model, EPlayImpl)
		if (rootPlay !== null){
			val candidatesTopics = EcoreUtil2.getAllContentsOfType(rootPlay, ENotifiedTopicImpl)
			for (candidate: candidatesTopics){
				acceptor.accept(createCompletionProposal("\"".concat(candidate.name).concat("\""), context))
			}
		}
	}
	
	def void createNonEditableCompletionProposal(String proposalText, String displayText,
	ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
			configurable.setAutoInsertable(false);
		}
		acceptor.accept(proposal)
	}
	
	def void createEditableCompletionProposal(String proposalText, String displayText,
		ContentAssistContext context, String additionalProposalInfo, ICompletionProposalAcceptor acceptor) {
		var ICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);
		if (proposal instanceof ConfigurableCompletionProposal) {
			val ConfigurableCompletionProposal configurable = proposal as ConfigurableCompletionProposal;
			configurable.setSelectionStart(configurable.getReplacementOffset());
			configurable.setSelectionLength(proposalText.length());
			configurable.setAutoInsertable(false);
			configurable.setSimpleLinkedMode(context.getViewer(), '\t', ' ');
			configurable.setAdditionalProposalInfo(additionalProposalInfo);
		}
		acceptor.accept(proposal)
	}
}
